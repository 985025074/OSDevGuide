# futex

- Commit: `6ef8e34f871575038c69d785857b2d88fba64a00`
- Date: `2025-12-20`
- Range: `ceacb089766c4055cbdbb7fd58b0e378bb8788a3..HEAD`

## 影响范围

- `syscall`, `task`, `trap`

## 主要改动

- 实现 futex WAIT/WAKE（含 BITSET 变体）最小子集，为 pthread 同步提供内核支撑。
- 补齐 thread-like clone(CLONE_VM) + tid 语义 + clear_child_tid 退出唤醒（pthread join 关键）。
- 新增 sched\_\* 系列 syscall 的最小兼容实现，并改进信号投递唤醒阻塞线程。

## 新增功能（做了什么 + 在哪）

### 1) futex 最小子集：WAIT/WAKE（含 BITSET 变体）

**涉及文件**

- `src/syscall/futex.rs`：新增 futex 队列与 `syscall_futex`。
- `src/syscall/mod.rs`：注册 syscall 98 并分发。

**实现方式（关键点）**

- 以 `(pid, uaddr)` 作为 key（`type FutexKey = (usize, usize)`），在全局 `BTreeMap` 里维护等待队列：
  - `FUTEX_QUEUES: Mutex<BTreeMap<FutexKey, VecDeque<Arc<TaskControlBlock>>>>`
- `FUTEX_WAIT/FUTEX_WAIT_BITSET`：
  - 先读取 `*uaddr`（用户态 32-bit 值），若 `cur != val` 返回 `-EAGAIN`（避免丢唤醒）。
  - 满足条件则把当前 task 入队，并 `block_current_and_run_next()`。
- `FUTEX_WAKE/FUTEX_WAKE_BITSET`：
  - 从队列中弹出最多 `val` 个 task，逐个 `wakeup_task()`。
  - 队列清空后从 map 移除 key。

**兼容性取舍**

- 当前实现忽略 `_timeout/_uaddr2/_val3`（即不支持超时/重排队/PI/robust futex 等）。
- 仍然足够覆盖 pthread 的常见 fast-path（互斥/条件变量的基础阻塞唤醒）。

### 2) 支持“线程式 clone”：CLONE_VM + tid 语义

**涉及文件**

- `src/syscall/process.rs::syscall_clone`
- `src/task/id.rs`：支持“只分配 TrapContext，不分配内核管理用户栈”的线程资源。
- `src/task/task_block.rs` / `src/task/process_block.rs`：补齐 Linux thread 需要的资源字段。

**做了什么**

- 当 `flags & CLONE_VM != 0`：不再走 fork-like 的进程复制，而是创建共享地址空间的“线程”。
- 拷贝父线程 TrapContext：
  - 子线程从 `clone` 返回 0（`a0/x10 = 0`）。
  - 若 `stack != 0`，使用用户传入的栈指针（glibc pthread 栈通常由 userspace `mmap` 分配）。
  - 若 `CLONE_SETTLS`，把 `_tls` 写入 `tp/x4`（TLS 基址）。
- `CLONE_PARENT_SETTID/CLONE_CHILD_SETTID`：在共享地址空间内写回 tid。
- 把新 task 挂到进程的 `tasks[tid]` 槽位，保证后续 tid -> task 可追踪。

### 3) clear_child_tid + futex wake：让 pthread join 不再卡死

**涉及文件**

- `src/syscall/misc.rs::syscall_set_tid_address`：记录 `clear_child_tid` 指针。
- `src/task/processor.rs::exit_current_and_run_next`：线程退出时清 0 并唤醒 futex waiters。

**会触发什么问题（修复前）**

- glibc pthread 的 join 典型逻辑是：
  - 子线程退出时：内核把 `*ctid` 清 0，并 `futex_wake(ctid)`。
  - join 的线程：`futex_wait(ctid, child_tid)` 等待该地址变化。
- 若内核缺少 clear_child_tid 或缺少 futex wake：
  - 表现为：`pthread_join()` 永久阻塞（线程已退出但 join 等不到唤醒）。

**修复后的行为**

- 退出路径写 `*ctid = 0`，并调用 `futex_wake(process_pid, ctid, 1)`。

### 4) sched\_\* 最小实现（rt-tests/工具链常用）

**涉及文件**

- `src/syscall/sched.rs`：新增 sched 系列 syscall 的兼容实现。
- `src/task/process_block.rs`：在 `ProcessControlBlockInner` 增加 `sched_policy/sched_priority`，fork 时继承。

**实现要点**

- `sched_getscheduler/getparam/setparam/setscheduler`：读写 PCB 里的 policy/priority。
- `sched_getaffinity`：返回一个“全 CPU 可用”的 mask（位数按 `MAX_HARTS` 生成）。
- `sched_setaffinity`：best-effort 接受但不强制（当前调度器不实现 affinity）。
- `sched_rr_get_interval`：写回 0 值 timespec。

### 5) 信号投递的唤醒与错误码更像 Linux

**涉及文件**

- `src/task/signal.rs`：kill/kill_current 对非法 pid/signum 返回 `-ESRCH/-EINVAL`，并在投递信号后唤醒目标进程的所有线程。

**修复前典型表现**

- 线程被信号打断时仍保持阻塞，用户态看到“信号已发送但线程不响应/不退出”。

## 文件变更

```text
 src/syscall/futex.rs      |  96 ++++++++++++++++++++++++++
 src/syscall/misc.rs       |  11 ++-
 src/syscall/mod.rs        |  22 ++++++
 src/syscall/process.rs    |  77 +++++++++++++++++++--
 src/syscall/sched.rs      | 170 ++++++++++++++++++++++++++++++++++++++++++++++
 src/task/id.rs            |  63 +++++++++++++----
 src/task/mod.rs           |   2 +-
 src/task/process_block.rs |   9 +++
 src/task/processor.rs     |  17 ++++-
 src/task/signal.rs        |  76 ++++++++++++++++-----
 src/task/task_block.rs    |  27 ++++++++
 src/trap/mod.rs           |  10 +--
 12 files changed, 531 insertions(+), 49 deletions(-)
```

## 简单验证（建议）

- pthread 基础：创建线程 + `pthread_join()` 不应卡死。
- futex：用户态用一块共享内存做 `FUTEX_WAIT`/`FUTEX_WAKE`（val 不匹配应返回 `-EAGAIN`）。
- sched：`sched_getaffinity()` 返回的 mask 应至少包含 cpu0。
